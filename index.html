<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E2E Locator Generator Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Inter', sans-serif;
        }

        .glass-effect {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, #667eea, #764ba2);
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, #5a67d8, #6b46c1);
        }

        .modal {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal-content {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .locator-card {
            transition: all 0.2s ease;
            border-left: 4px solid transparent;
        }

        .locator-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            border-left-color: #667eea;
        }

        .ai-content {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        }

        .loading-shimmer {
            background: linear-gradient(90deg, #f1f5f9 25%, #e2e8f0 50%, #f1f5f9 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        .pulse-animation {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .code-block {
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            background: #1e293b;
            color: #e2e8f0;
            border-radius: 8px;
            position: relative;
        }

        .copy-success {
            background: #10b981 !important;
            color: white !important;
        }
    </style>
</head>

<body class="min-h-screen gradient-bg">
    <div class="min-h-screen flex flex-col">
        <header class="glass-effect shadow-lg sticky top-0 z-50">
            <div class="max-w-7xl mx-auto px-6 py-4">
                <div class="flex justify-between items-center">
                    <div class="flex items-center space-x-4">
                        <div class="p-3 bg-gradient-to-br from-blue-600 to-purple-600 rounded-xl shadow-lg">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                                <path d="M9 12l2 2 4-4"></path>
                                <path d="M21 12c-1.5 0-3-1-3-3s1.5-3 3-3 3 1 3 3-1.5 3-3 3"></path>
                                <path d="M3 12c1.5 0 3-1 3-3s-1.5-3-3-3-3 1-3 3 1.5 3 3 3"></path>
                            </svg>
                        </div>
                        <div>
                            <h1 class="text-2xl font-bold text-slate-800">E2E Locator Generator</h1>
                            <p class="text-sm text-slate-600">AI-powered test automation assistant</p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-3">
                        <div id="api-status"
                            class="hidden flex items-center space-x-2 px-3 py-1 rounded-full bg-green-100 text-green-800 text-sm">
                            <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                            <span>API Connected</span>
                        </div>
                        <button id="settings-btn" class="p-2 rounded-xl hover:bg-white/50 transition-colors">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <circle cx="12" cy="12" r="3"></circle>
                                <path
                                    d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                                </path>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <main class="flex-1 max-w-7xl mx-auto w-full px-6 py-8">
            <div class="lg:flex lg:space-x-8 h-full">
                <div class="glass-effect rounded-2xl shadow-xl p-6 flex flex-col lg:flex-1 mb-8 lg:mb-0">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold text-slate-800">HTML Input</h2>
                        <div class="flex space-x-2">
                            <button id="clear-btn"
                                class="px-3 py-1 text-sm bg-slate-200 hover:bg-slate-300 rounded-lg transition-colors">
                                Clear
                            </button>
                            <button id="format-btn"
                                class="px-3 py-1 text-sm bg-blue-100 hover:bg-blue-200 text-blue-700 rounded-lg transition-colors">
                                Format
                            </button>
                        </div>
                    </div>

                    <textarea id="html-input"
                        class="flex-1 w-full border-2 border-slate-200 rounded-xl p-4 focus:border-blue-400 focus:outline-none transition-colors custom-scrollbar resize-none"
                        placeholder="Paste your HTML snippet here...
                        
Example:
<button id=&quot;submit-btn&quot; class=&quot;btn primary&quot;>Submit</button>
<div class=&quot;form-group&quot;>
  <input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Enter email&quot;>
</div>"></textarea>

                    <div class="flex items-center justify-between mt-4">
                        <div class="flex items-center space-x-4">
                            <div class="flex items-center space-x-2">
                                <input type="checkbox" id="include-ai" class="rounded" checked>
                                <label for="include-ai" class="text-sm text-slate-700">AI Suggestions</label>
                            </div>
                            <div class="flex items-center space-x-2">
                                <input type="checkbox" id="include-best-practices" class="rounded" checked>
                                <label for="include-best-practices" class="text-sm text-slate-700">Best
                                    Practices</label>
                            </div>
                        </div>
                        <button id="generate-btn"
                            class="px-6 py-3 bg-gradient-to-r from-blue-600 to-purple-600 text-white font-semibold rounded-xl hover:from-blue-700 hover:to-purple-700 transition-all transform hover:scale-105 shadow-lg disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                            <span class="flex items-center space-x-2">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <polygon points="13,2 3,14 12,14 11,22 21,10 12,10"></polygon>
                                </svg>
                                <span>Generate Locators</span>
                            </span>
                        </button>
                    </div>
                </div>

                <div class="glass-effect rounded-2xl shadow-xl p-6 flex flex-col lg:flex-1">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold text-slate-800">Generated Locators</h2>
                        <div class="flex space-x-2">
                            <button id="export-btn"
                                class="px-3 py-1 text-sm bg-green-100 hover:bg-green-200 text-green-700 rounded-lg transition-colors disabled:opacity-50"
                                disabled>
                                Export
                            </button>
                            <select id="filter-select" class="px-3 py-1 text-sm border border-slate-200 rounded-lg">
                                <option value="all">All Locators</option>
                                <option value="css">CSS Only</option>
                                <option value="xpath">XPath Only</option>
                                <option value="ai">AI Suggestions</option>
                            </select>
                        </div>
                    </div>

                    <div id="output-container" class="flex-1 overflow-y-auto custom-scrollbar">
                        <div id="empty-state" class="h-full flex flex-col items-center justify-center text-slate-400">
                            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="1">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14,2 14,8 20,8"></polyline>
                                <line x1="16" y1="13" x2="8" y2="13"></line>
                                <line x1="16" y1="17" x2="8" y2="17"></line>
                                <polyline points="10,9 9,9 8,9"></polyline>
                            </svg>
                            <p class="mt-4 text-center">Your generated locators will appear here</p>
                            <p class="text-sm text-slate-400">Paste HTML and click "Generate Locators" to get started
                            </p>
                        </div>
                        <div id="output-content" class="space-y-6 hidden"></div>
                    </div>
                </div>
            </div>
        </main>

        <div id="chat-bubble"
            class="fixed bottom-6 right-6 z-50 w-14 h-14 bg-blue-600 rounded-full flex items-center justify-center shadow-lg cursor-pointer hover:scale-110 transition-transform duration-300">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
        </div>

        <div id="chat-modal"
            class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 invisible opacity-0 z-50">
            <div
                class="modal-content glass-effect w-full max-w-lg p-6 rounded-2xl shadow-2xl transform scale-95 flex flex-col max-h-[90vh]">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold text-slate-800">AI Chat Assistant</h2>
                    <button id="close-chat-modal-btn" class="p-2 rounded-xl hover:bg-slate-200 transition-colors">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div id="chat-history" class="flex-1 overflow-y-auto custom-scrollbar p-2 mb-4 space-y-4">
                    <div class="flex justify-start">
                        <div class="bg-blue-100 text-blue-800 p-3 rounded-xl max-w-[80%]">
                            Hello! I can help you with your locators or answer any questions about the provided HTML.
                        </div>
                    </div>
                </div>
                <div class="flex items-center space-x-2">
                    <textarea id="chat-input" rows="1"
                        class="flex-1 border-2 border-slate-200 rounded-xl p-3 focus:border-blue-400 focus:outline-none resize-none custom-scrollbar"
                        placeholder="Ask me anything about your HTML..."></textarea>
                    <button id="chat-send-btn"
                        class="p-3 bg-blue-600 text-white rounded-xl hover:bg-blue-700 transition-colors disabled:opacity-50">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" class="-rotate-45">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <div id="settings-modal"
            class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 invisible opacity-0 z-50">
            <div class="modal-content glass-effect w-full max-w-lg p-8 rounded-2xl shadow-2xl transform scale-95">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-slate-800">Settings</h2>
                    <button id="close-modal-btn" class="p-2 rounded-xl hover:bg-slate-200 transition-colors">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>

                <div class="space-y-6">
                    <div>
                        <label for="api-key-input" class="block text-sm font-semibold text-slate-700 mb-3">Gemini API
                            Key</label>
                        <input type="password" id="api-key-input"
                            class="w-full border-2 border-slate-200 rounded-xl p-3 focus:border-blue-400 focus:outline-none transition-colors"
                            placeholder="Enter your Gemini API key">
                        <p class="text-xs text-slate-500 mt-2">Your API key is stored locally and never sent to our
                            servers.
                        </p>
                    </div>

                    <div>
                        <label class="block text-sm font-semibold text-slate-700 mb-3">AI Model</label>
                        <select id="model-select"
                            class="w-full border-2 border-slate-200 rounded-xl p-3 focus:border-blue-400 focus:outline-none">
                            <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                            <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                        </select>
                    </div>

                    <div>
                        <label class="block text-sm font-semibold text-slate-700 mb-3">Generation Options</label>
                        <div class="space-y-2">
                            <label class="flex items-center space-x-2">
                                <input type="checkbox" id="priority-interactive" class="rounded" checked>
                                <span class="text-sm">Prioritize interactive elements</span>
                            </label>
                            <label class="flex items-center space-x-2">
                                <input type="checkbox" id="include-explanations" class="rounded" checked>
                                <span class="text-sm">Include detailed explanations</span>
                            </label>
                            <label class="flex items-center space-x-2">
                                <input type="checkbox" id="stability-focus" class="rounded" checked>
                                <span class="text-sm">Focus on stability over brevity</span>
                            </label>
                        </div>
                    </div>
                </div>

                <div class="flex justify-end space-x-3 mt-8">
                    <button id="cancel-settings-btn"
                        class="px-4 py-2 text-slate-600 hover:text-slate-800 transition-colors">
                        Cancel
                    </button>
                    <button id="save-settings-btn"
                        class="px-6 py-2 bg-gradient-to-r from-blue-600 to-purple-600 text-white font-semibold rounded-xl hover:from-blue-700 hover:to-purple-700 transition-all">
                        Save Settings
                    </button>
                </div>
            </div>
        </div>

        <div id="toast-container" class="fixed bottom-6 right-6 space-y-2 z-50"></div>

        <script>
            // Global state
            let apiKey = '';
            let selectedModel = 'gemini-1.5-pro';
            let generatedLocators = [];
            const showdownConverter = new showdown.Converter();

            // DOM elements
            const settingsBtn = document.getElementById('settings-btn');
            const settingsModal = document.getElementById('settings-modal');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const cancelSettingsBtn = document.getElementById('cancel-settings-btn');
            const saveSettingsBtn = document.getElementById('save-settings-btn');
            const apiKeyInput = document.getElementById('api-key-input');
            const modelSelect = document.getElementById('model-select');
            const generateBtn = document.getElementById('generate-btn');
            const htmlInput = document.getElementById('html-input');
            const outputContainer = document.getElementById('output-container');
            const outputContent = document.getElementById('output-content');
            const emptyState = document.getElementById('empty-state');
            const clearBtn = document.getElementById('clear-btn');
            const formatBtn = document.getElementById('format-btn');
            const exportBtn = document.getElementById('export-btn');
            const filterSelect = document.getElementById('filter-select');
            const apiStatus = document.getElementById('api-status');
            const toastContainer = document.getElementById('toast-container');

            // Chat elements
            const chatBubble = document.getElementById('chat-bubble');
            const chatModal = document.getElementById('chat-modal');
            const closeChatModalBtn = document.getElementById('close-chat-modal-btn');
            const chatHistory = document.getElementById('chat-history');
            const chatInput = document.getElementById('chat-input');
            const chatSendBtn = document.getElementById('chat-send-btn');

            // Settings modal functions
            function openModal() {
                settingsModal.classList.remove('invisible', 'opacity-0');
                settingsModal.querySelector('.modal-content').classList.remove('scale-95');
            }

            function closeModal() {
                settingsModal.classList.add('invisible', 'opacity-0');
                settingsModal.querySelector('.modal-content').classList.add('scale-95');
            }

            // Event listeners for modal
            settingsBtn.addEventListener('click', openModal);
            closeModalBtn.addEventListener('click', closeModal);
            cancelSettingsBtn.addEventListener('click', closeModal);
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) closeModal();
            });

            // Save settings
            saveSettingsBtn.addEventListener('click', () => {
                const key = apiKeyInput.value.trim();
                const model = modelSelect.value;

                if (key) {
                    apiKey = key;
                    selectedModel = model;
                    localStorage.setItem('gemini-api-key', key);
                    localStorage.setItem('selected-model', model);
                    updateApiStatus(true);
                    showToast('Settings saved successfully!', 'success');
                } else {
                    showToast('Please enter a valid API key', 'error');
                    return;
                }

                closeModal();
            });

            // Toast notification system
            function showToast(message, type = 'info', duration = 3000) {
                const toast = document.createElement('div');
                const colors = {
                    success: 'bg-green-500',
                    error: 'bg-red-500',
                    info: 'bg-blue-500',
                    warning: 'bg-yellow-500'
                };

                toast.className = `${colors[type]} text-white px-4 py-3 rounded-xl shadow-lg transform translate-x-full transition-transform duration-300 flex items-center space-x-2`;
                toast.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    ${type === 'success' ? '<path d="M9 12l2 2 4-4"></path><path d="M21 12c-1 0-3-1-3-3s1.5-3 3-3 3 1 3 3-1.5 3-3 3"></path>' :
                        type === 'error' ? '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>' :
                            '<circle cx="12" cy="12" r="10"></circle><path d="M12 6v6l4 2"></path>'}
                </svg>
                <span>${message}</span>
            `;

                toastContainer.appendChild(toast);

                setTimeout(() => toast.classList.remove('translate-x-full'), 100);
                setTimeout(() => {
                    toast.classList.add('translate-x-full');
                    setTimeout(() => toast.remove(), 300);
                }, duration);
            }

            // Update API status indicator
            function updateApiStatus(connected) {
                if (connected) {
                    apiStatus.classList.remove('hidden');
                } else {
                    apiStatus.classList.add('hidden');
                }
            }

            // Load saved settings
            function loadSettings() {
                const savedKey = localStorage.getItem('gemini-api-key');
                const savedModel = localStorage.getItem('selected-model');

                if (savedKey) {
                    apiKey = savedKey;
                    apiKeyInput.value = savedKey;
                    updateApiStatus(true);
                }

                if (savedModel) {
                    selectedModel = savedModel;
                    modelSelect.value = savedModel;
                }
            }

            // Clear input
            clearBtn.addEventListener('click', () => {
                htmlInput.value = '';
                clearOutput();
            });

            // Format HTML
            formatBtn.addEventListener('click', () => {
                const html = htmlInput.value.trim();
                if (!html) return;

                try {
                    const formatted = formatHtml(html);
                    htmlInput.value = formatted;
                    showToast('HTML formatted successfully!', 'success');
                } catch (error) {
                    showToast('Error formatting HTML', 'error');
                }
            });

            // Simple HTML formatter
            function formatHtml(html) {
                let formatted = html;
                let indent = 0;
                const tab = '  ';

                formatted = formatted.replace(/></g, '>\n<');

                const lines = formatted.split('\n');
                const result = [];

                lines.forEach(line => {
                    const trimmed = line.trim();
                    if (!trimmed) return;

                    if (trimmed.match(/^<\/\w/)) {
                        indent = Math.max(0, indent - 1);
                    }

                    result.push(tab.repeat(indent) + trimmed);

                    if (trimmed.match(/^<\w[^>]*[^/]>$/)) {
                        indent++;
                    }
                });

                return result.join('\n');
            }

            // Export functionality
            exportBtn.addEventListener('click', () => {
                if (generatedLocators.length === 0) return;

                const exportData = {
                    timestamp: new Date().toISOString(),
                    locators: generatedLocators
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `locators-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);

                showToast('Locators exported successfully!', 'success');
            });

            // Filter functionality
            filterSelect.addEventListener('change', () => {
                const filterValue = filterSelect.value;
                const sections = outputContent.querySelectorAll('.locator-section');

                sections.forEach(section => {
                    const sectionType = section.dataset.type;
                    if (filterValue === 'all' || sectionType === filterValue) {
                        section.style.display = 'block';
                    } else {
                        section.style.display = 'none';
                    }
                });
            });

            // Clear output
            function clearOutput() {
                outputContent.innerHTML = '';
                outputContent.classList.add('hidden');
                emptyState.classList.remove('hidden');
                exportBtn.disabled = true;
                generatedLocators = [];
            }

            // Show output
            function showOutput() {
                emptyState.classList.add('hidden');
                outputContent.classList.remove('hidden');
                exportBtn.disabled = false;
            }

            // Create locator card
            function createLocatorCard(locator, type, explanation = '', priority = 'medium') {
                const priorityColors = {
                    high: 'border-l-green-500 bg-green-50',
                    medium: 'border-l-blue-500 bg-blue-50',
                    low: 'border-l-yellow-500 bg-yellow-50'
                };

                const card = document.createElement('div');
                card.className = `locator-card p-4 rounded-xl border-2 border-slate-100 ${priorityColors[priority]} fade-in`;

                card.innerHTML = `
                <div class="flex justify-between items-start mb-2">
                    <div class="flex items-center space-x-2">
                        <span class="px-2 py-1 text-xs font-semibold rounded-full ${type === 'CSS' ? 'bg-blue-100 text-blue-800' : 'bg-purple-100 text-purple-800'}">${type}</span>
                        <span class="px-2 py-1 text-xs rounded-full ${priority === 'high' ? 'bg-green-100 text-green-800' : priority === 'medium' ? 'bg-blue-100 text-blue-800' : 'bg-yellow-100 text-yellow-800'}">${priority.toUpperCase()}</span>
                    </div>
                    <button class="copy-btn p-2 rounded-lg hover:bg-white/50 transition-colors" title="Copy locator">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    </button>
                </div>
                <div class="code-block p-3 mb-2">
                    <code class="text-sm break-all">${escapeHtml(locator)}</code>
                </div>
                ${explanation ? `<p class="text-sm text-slate-600">${explanation}</p>` : ''}
            `;

                // Copy functionality
                card.querySelector('.copy-btn').addEventListener('click', () => {
                    copyToClipboard(locator, card.querySelector('.copy-btn'));
                });

                return card;
            }

            // Create section header
            function createSectionHeader(title, count = 0) {
                const header = document.createElement('div');
                header.className = 'flex items-center justify-between mb-4';
                header.innerHTML = `
                <h3 class="text-lg font-semibold text-slate-800">${title}</h3>
                ${count > 0 ? `<span class="px-2 py-1 bg-slate-200 text-slate-600 rounded-full text-sm">${count} items</span>` : ''}
            `;
                return header;
            }

            // Copy to clipboard with visual feedback
            function copyToClipboard(text, button) {
                const originalContent = button.innerHTML;

                navigator.clipboard.writeText(text).then(() => {
                    button.classList.add('copy-success');
                    button.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 12l2 2 4-4"></path>
                        <path d="M21 12c-1 0-3-1-3-3s1.5-3 3-3 3 1 3 3-1.5 3-3 3"></path>
                    </svg>
                `;

                    setTimeout(() => {
                        button.classList.remove('copy-success');
                        button.innerHTML = originalContent;
                    }, 1000);

                    showToast('Copied to clipboard!', 'success', 1500);
                }).catch(() => {
                    showToast('Failed to copy', 'error');
                });
            }

            // Utility function to escape HTML
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Generate rule-based locators
            function generateRuleBasedLocators(htmlContent) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                const elements = doc.body.querySelectorAll('*');

                const locators = [];
                const seenLocators = new Set();

                elements.forEach((element, index) => {
                    const tagName = element.tagName.toLowerCase();
                    const locatorData = [];

                    // ID-based locators (highest priority)
                    if (element.id) {
                        const cssId = `#${element.id}`;
                        const xpathId = `//${tagName}[@id='${element.id}']`;

                        if (!seenLocators.has(cssId)) {
                            locatorData.push({
                                locator: cssId,
                                type: 'CSS',
                                priority: 'high',
                                explanation: `Unique ID selector - most reliable and fast`
                            });
                            seenLocators.add(cssId);
                        }

                        if (!seenLocators.has(xpathId)) {
                            locatorData.push({
                                locator: xpathId,
                                type: 'XPath',
                                priority: 'high',
                                explanation: `ID-based XPath - highly reliable`
                            });
                            seenLocators.add(xpathId);
                        }
                    }

                    // Name attribute (for form elements)
                    if (element.name) {
                        const cssName = `${tagName}[name='${element.name}']`;
                        const xpathName = `//${tagName}[@name='${element.name}']`;

                        if (!seenLocators.has(cssName)) {
                            locatorData.push({
                                locator: cssName,
                                type: 'CSS',
                                priority: 'high',
                                explanation: `Name attribute selector - reliable for form elements`
                            });
                            seenLocators.add(cssName);
                        }
                    }

                    // Class-based locators
                    if (element.classList.length > 0) {
                        const classes = Array.from(element.classList);
                        const cssClass = '.' + classes.join('.');
                        const xpathClass = `//${tagName}[${classes.map(c => `contains(@class, '${c}')`).join(' and ')}]`;

                        if (!seenLocators.has(cssClass) && classes.length <= 3) {
                            locatorData.push({
                                locator: cssClass,
                                type: 'CSS',
                                priority: classes.length === 1 ? 'medium' : 'low',
                                explanation: `Class-based selector - stability depends on CSS changes`
                            });
                            seenLocators.add(cssClass);
                        }
                    }

                    // Attribute-based locators
                    ['role', 'aria-label', 'data-testid', 'data-cy', 'placeholder', 'title', 'alt'].forEach(attr => {
                        if (element.hasAttribute(attr)) {
                            const value = element.getAttribute(attr);
                            const cssAttr = `${tagName}[${attr}='${value}']`;
                            const xpathAttr = `//${tagName}[@${attr}='${value}']`;

                            if (!seenLocators.has(cssAttr)) {
                                locatorData.push({
                                    locator: cssAttr,
                                    type: 'CSS',
                                    priority: ['data-testid', 'data-cy', 'role', 'aria-label'].includes(attr) ? 'high' : 'medium',
                                    explanation: `${attr} attribute selector - ${['data-testid', 'data-cy'].includes(attr) ? 'designed for testing' : 'semantic meaning'}`
                                });
                                seenLocators.add(cssAttr);
                            }
                        }
                    });

                    // Text-based XPath (for elements with short, unique text)
                    const text = element.textContent?.trim();
                    if (text && text.length < 50 && element.children.length === 0) {
                        const xpathText = `//${tagName}[text()='${text.replace(/'/g, "\\'")}']`;
                        const xpathContains = `//${tagName}[contains(text(), '${text.substring(0, 20).replace(/'/g, "\\'")}')]`;

                        if (!seenLocators.has(xpathText)) {
                            locatorData.push({
                                locator: xpathText,
                                type: 'XPath',
                                priority: 'medium',
                                explanation: `Exact text match - can break if text changes`
                            });
                            seenLocators.add(xpathText);
                        }

                        if (!seenLocators.has(xpathContains) && text.length > 20) {
                            locatorData.push({
                                locator: xpathContains,
                                type: 'XPath',
                                priority: 'low',
                                explanation: `Partial text match - more flexible but less specific`
                            });
                            seenLocators.add(xpathContains);
                        }
                    }

                    // Position-based locators (last resort)
                    if (element.parentElement && element.parentElement.children.length > 1) {
                        const siblings = Array.from(element.parentElement.children);
                        const position = siblings.indexOf(element) + 1;
                        const tagSiblings = siblings.filter(el => el.tagName === element.tagName);

                        if (tagSiblings.length > 1) {
                            const typePosition = tagSiblings.indexOf(element) + 1;
                            const cssNth = `${element.parentElement.tagName.toLowerCase()} > ${tagName}:nth-of-type(${typePosition})`;

                            if (!seenLocators.has(cssNth)) {
                                locatorData.push({
                                    locator: cssNth,
                                    type: 'CSS',
                                    priority: 'low',
                                    explanation: `Position-based selector - fragile, use only if no alternatives`
                                });
                                seenLocators.add(cssNth);
                            }
                        }
                    }

                    locators.push(...locatorData);
                });

                return locators;
            }

            // Generate AI-powered locators
            async function generateAiLocators(htmlContent) {
                if (!apiKey) {
                    throw new Error('API key not configured');
                }

                const includeExplanations = document.getElementById('include-explanations')?.checked ?? true;
                const prioritizeInteractive = document.getElementById('priority-interactive')?.checked ?? true;
                const stabilityFocus = document.getElementById('stability-focus')?.checked ?? true;

                const prompt = `
As an expert QA automation engineer, analyze this HTML snippet and provide optimal test locators.

HTML:
\`\`\`html
${htmlContent}
\`\`\`

Requirements:
- ${prioritizeInteractive ? 'Focus on interactive elements (buttons, inputs, links, forms)' : 'Analyze all elements equally'}
- ${stabilityFocus ? 'Prioritize stability and maintainability over brevity' : 'Balance brevity with stability'}
- Provide both CSS selectors and XPath expressions
- ${includeExplanations ? 'Include detailed explanations for each recommendation' : 'Provide brief explanations'}
- Rank recommendations by reliability (High|Medium|Low priority)
- Identify potential anti-patterns to avoid

Format your response as a JSON object with this structure. You MUST ONLY respond with the JSON object. Do not include any other text, explanations, or commentary.
{
  "recommendations": [
    {
      "element": "brief element description",
      "cssSelector": "css selector here",
      "xpath": "xpath expression here",
      "priority": "High|Medium|Low",
      "explanation": "why this locator is recommended",
      "alternatives": ["alternative locator 1", "alternative locator 2"]
    }
  ],
  "bestPractices": [
    "practice 1",
    "practice 2"
  ],
  "antiPatterns": [
    "avoid this pattern because...",
    "avoid this other pattern because..."
  ]
}
`;

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: prompt
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.3,
                            maxOutputTokens: 4096
                        }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                const content = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!content) {
                    throw new Error('Empty response from AI');
                }

                try {
                    // Robust JSON extraction
                    const startIndex = content.indexOf('{');
                    const endIndex = content.lastIndexOf('}');
                    if (startIndex === -1 || endIndex === -1) {
                        throw new Error('No valid JSON found in response');
                    }
                    const jsonString = content.substring(startIndex, endIndex + 1);
                    const aiData = JSON.parse(jsonString);
                    return aiData;
                } catch (parseError) {
                    console.error('Failed to parse AI response:', content);
                    throw new Error('Invalid JSON response from AI');
                }
            }

            // Create AI recommendations section
            function createAiSection(aiData) {
                const section = document.createElement('div');
                section.className = 'locator-section ai-content p-6 rounded-xl fade-in';
                section.dataset.type = 'ai';

                const header = createSectionHeader('🤖 AI Recommendations', aiData.recommendations?.length || 0);
                section.appendChild(header);

                if (aiData.recommendations && aiData.recommendations.length > 0) {
                    const grid = document.createElement('div');
                    grid.className = 'space-y-4';

                    aiData.recommendations.forEach(rec => {
                        // CSS Selector card
                        if (rec.cssSelector) {
                            const cssCard = createLocatorCard(
                                rec.cssSelector,
                                'CSS',
                                `${rec.element}: ${rec.explanation}`,
                                rec.priority?.toLowerCase() || 'medium'
                            );
                            grid.appendChild(cssCard);
                        }

                        // XPath card
                        if (rec.xpath) {
                            const xpathCard = createLocatorCard(
                                rec.xpath,
                                'XPath',
                                `${rec.element}: ${rec.explanation}`,
                                rec.priority?.toLowerCase() || 'medium'
                            );
                            grid.appendChild(xpathCard);
                        }

                        // Alternatives
                        if (rec.alternatives && rec.alternatives.length > 0) {
                            rec.alternatives.forEach(alt => {
                                const altCard = createLocatorCard(
                                    alt,
                                    alt.startsWith('//') ? 'XPath' : 'CSS',
                                    `Alternative for ${rec.element}`,
                                    'low'
                                );
                                grid.appendChild(altCard);
                            });
                        }
                    });

                    section.appendChild(grid);
                }

                // Best practices section
                if (aiData.bestPractices && aiData.bestPractices.length > 0) {
                    const practicesDiv = document.createElement('div');
                    practicesDiv.className = 'mt-6 p-4 bg-green-50 rounded-xl border border-green-200';
                    practicesDiv.innerHTML = `
                        <h4 class="font-semibold text-green-800 mb-2">✅ Best Practices</h4>
                        <ul class="text-sm text-green-700 space-y-1">
                            ${aiData.bestPractices.map(practice => `<li>• ${escapeHtml(practice)}</li>`).join('')}
                        </ul>
                    `;
                    section.appendChild(practicesDiv);
                }

                // Anti-patterns section
                if (aiData.antiPatterns && aiData.antiPatterns.length > 0) {
                    const antiPatternsDiv = document.createElement('div');
                    antiPatternsDiv.className = 'mt-4 p-4 bg-red-50 rounded-xl border border-red-200';
                    antiPatternsDiv.innerHTML = `
                        <h4 class="font-semibold text-red-800 mb-2">❌ Avoid These Patterns</h4>
                        <ul class="text-sm text-red-700 space-y-1">
                            ${aiData.antiPatterns.map(pattern => `<li>• ${escapeHtml(pattern)}</li>`).join('')}
                        </ul>
                    `;
                    section.appendChild(antiPatternsDiv);
                }

                return section;
            }

            // Create rule-based section
            function createRuleBasedSection(locators) {
                const section = document.createElement('div');
                section.className = 'locator-section';
                section.dataset.type = 'css';

                const header = createSectionHeader('⚙️ Rule-Based Locators', locators.length);
                section.appendChild(header);

                // Group by priority
                const grouped = {
                    high: locators.filter(l => l.priority === 'high'),
                    medium: locators.filter(l => l.priority === 'medium'),
                    low: locators.filter(l => l.priority === 'low')
                };

                Object.entries(grouped).forEach(([priority, items]) => {
                    if (items.length === 0) return;

                    const prioritySection = document.createElement('div');
                    prioritySection.className = 'mb-6';

                    const priorityHeader = document.createElement('h4');
                    priorityHeader.className = `text-md font-semibold mb-3 ${priority === 'high' ? 'text-green-700' : priority === 'medium' ? 'text-blue-700' : 'text-yellow-700'}`;
                    priorityHeader.textContent = `${priority.charAt(0).toUpperCase() + priority.slice(1)} Priority (${items.length})`;
                    prioritySection.appendChild(priorityHeader);

                    const grid = document.createElement('div');
                    grid.className = 'space-y-3';

                    items.forEach(item => {
                        const card = createLocatorCard(item.locator, item.type, item.explanation, item.priority);
                        grid.appendChild(card);
                    });

                    prioritySection.appendChild(grid);
                    section.appendChild(prioritySection);
                });

                return section;
            }

            // Main generation function
            generateBtn.addEventListener('click', async () => {
                const htmlContent = htmlInput.value.trim();

                if (!htmlContent) {
                    showToast('Please enter HTML content first', 'warning');
                    return;
                }

                // Clear previous results
                clearOutput();
                showOutput();

                generateBtn.disabled = true;
                generateBtn.innerHTML = `
                <span class="flex items-center space-x-2">
                    <svg class="animate-spin" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12a9 9 0 0 0-9-9m9 9a9 9 0 0 1-9 9m9-9H3m9 0a9 9 0 1 0 0 18"/>
                    </svg>
                    <span>Generating...</span>
                </span>
            `;

                try {
                    // Generate rule-based locators
                    const ruleBasedLocators = generateRuleBasedLocators(htmlContent);
                    generatedLocators.push(...ruleBasedLocators);

                    if (ruleBasedLocators.length > 0) {
                        const ruleSection = createRuleBasedSection(ruleBasedLocators);
                        outputContent.appendChild(ruleSection);
                    }

                    // Generate AI locators if enabled and API key is available
                    if (document.getElementById('include-ai')?.checked && apiKey) {
                        try {
                            const aiData = await generateAiLocators(htmlContent);

                            if (aiData.recommendations) {
                                generatedLocators.push(...aiData.recommendations.map(rec => ({
                                    locator: rec.cssSelector || rec.xpath,
                                    type: rec.cssSelector ? 'CSS' : 'XPath',
                                    priority: rec.priority?.toLowerCase() || 'medium',
                                    explanation: rec.explanation,
                                    source: 'ai'
                                })));
                            }

                            const aiSection = createAiSection(aiData);
                            outputContent.appendChild(aiSection);
                        } catch (aiError) {
                            console.error('AI generation failed:', aiError);
                            showToast(`AI generation failed: ${aiError.message}`, 'error');

                            // Show API key setup if that's the issue
                            if (aiError.message.includes('API key')) {
                                const setupDiv = document.createElement('div');
                                setupDiv.className = 'locator-section p-6 bg-yellow-50 rounded-xl border border-yellow-200';
                                setupDiv.innerHTML = `
                                <h3 class="text-lg font-semibold text-yellow-800 mb-2">🔑 API Key Required</h3>
                                <p class="text-yellow-700 mb-4">To enable AI-powered suggestions, please configure your Gemini API key.</p>
                                <button id="setup-api-btn" class="px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 transition-colors">
                                    Setup API Key
                                </button>
                            `;
                                outputContent.appendChild(setupDiv);

                                setupDiv.querySelector('#setup-api-btn').addEventListener('click', openModal);
                            }
                        }
                    }

                    if (generatedLocators.length === 0) {
                        const noResultsDiv = document.createElement('div');
                        noResultsDiv.className = 'text-center py-12 text-slate-500';
                        noResultsDiv.innerHTML = `
                        <svg class="mx-auto mb-4" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="M8 12h8"></path>
                        </svg>
                        <p>No locators could be generated from the provided HTML.</p>
                        <p class="text-sm mt-2">Try providing HTML with more identifiable elements.</p>
                    `;
                        outputContent.appendChild(noResultsDiv);
                    }

                } catch (error) {
                    console.error('Generation failed:', error);
                    showToast('Failed to generate locators', 'error');

                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'p-6 bg-red-50 rounded-xl border border-red-200 text-center';
                    errorDiv.innerHTML = `
                    <svg class="mx-auto mb-4 text-red-500" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="15" y1="9" x2="9" y2="15"></line>
                        <line x1="9" y1="9" x2="15" y2="15"></line>
                    </svg>
                    <h3 class="text-lg font-semibold text-red-800 mb-2">Generation Failed</h3>
                    <p class="text-red-700">${error.message}</p>
                `;
                    outputContent.appendChild(errorDiv);
                } finally {
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = `
                    <span class="flex items-center space-x-2">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polygon points="13,2 3,14 12,14 11,22 21,10 12,10"></polygon>
                        </svg>
                        <span>Generate Locators</span>
                    </span>
                `;
                }
            });

            // Chat functionality
            let isChatting = false;

            chatBubble.addEventListener('click', () => {
                chatModal.classList.remove('invisible', 'opacity-0');
                chatModal.querySelector('.modal-content').classList.remove('scale-95');
                chatInput.focus();
            });

            closeChatModalBtn.addEventListener('click', () => {
                chatModal.classList.add('invisible', 'opacity-0');
                chatModal.querySelector('.modal-content').classList.add('scale-95');
            });

            chatModal.addEventListener('click', (e) => {
                if (e.target === chatModal) {
                    chatModal.classList.add('invisible', 'opacity-0');
                    chatModal.querySelector('.modal-content').classList.add('scale-95');
                }
            });

            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (!isChatting) {
                        handleChatSend();
                    }
                }
            });
            chatInput.addEventListener('input', () => {
                chatInput.style.height = 'auto';
                chatInput.style.height = chatInput.scrollHeight + 'px';
            });

            chatSendBtn.addEventListener('click', () => {
                if (!isChatting) {
                    handleChatSend();
                }
            });

            async function handleChatSend() {
                const query = chatInput.value.trim();
                const htmlContent = htmlInput.value.trim();

                if (!query) return;

                if (!apiKey) {
                    showToast('Please set your API key in the settings to use the chat.', 'warning');
                    return;
                }

                isChatting = true;
                chatInput.value = '';
                chatSendBtn.disabled = true;

                // Display user message
                appendMessage(query, 'user');
                const loadingMessage = appendMessage('...', 'ai', true);

                try {
                    const response = await getChatResponse(query, htmlContent);
                    updateMessage(loadingMessage, response);
                } catch (error) {
                    console.error('Chat error:', error);
                    updateMessage(loadingMessage, `Sorry, an error occurred: ${error.message}`, true);
                } finally {
                    isChatting = false;
                    chatSendBtn.disabled = false;
                    chatHistory.scrollTop = chatHistory.scrollHeight;
                }
            }

            function appendMessage(text, sender, isLoading = false) {
                const messageDiv = document.createElement('div');
                const isUser = sender === 'user';
                messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'} fade-in`;

                const contentDiv = document.createElement('div');
                contentDiv.className = `p-3 rounded-xl max-w-[80%] ${isUser ? 'bg-blue-600 text-white' : 'bg-slate-100 text-slate-800'}`;

                if (isLoading) {
                    contentDiv.classList.add('loading-shimmer');
                } else {
                    contentDiv.innerHTML = showdownConverter.makeHtml(text);
                }

                messageDiv.appendChild(contentDiv);
                chatHistory.appendChild(messageDiv);
                chatHistory.scrollTop = chatHistory.scrollHeight;

                return contentDiv;
            }

            function updateMessage(element, newText, isError = false) {
                element.classList.remove('loading-shimmer');
                if (isError) {
                    element.classList.add('bg-red-100', 'text-red-800');
                } else {
                    element.classList.add('bg-slate-100', 'text-slate-800');
                }
                element.innerHTML = showdownConverter.makeHtml(newText);
            }

            async function getChatResponse(query, htmlContent) {
                const prompt = `
You are an AI assistant for a web testing tool. The user has provided an HTML snippet and a question. Your task is to provide a concise, helpful, and direct answer based on the provided context.
- Keep your answers short and to the point.
- If the question is about locators, provide the best locator(s) directly.
- Use markdown for formatting, like \`code blocks\` and **bold text**.
- Do not provide code examples that are not directly related to the user's query.

---
HTML Snippet:
\`\`\`html
${htmlContent}
\`\`\`
---
User Question:
${query}
---
Your direct and concise response:`;

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: prompt
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.5,
                            maxOutputTokens: 1024
                        }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                const content = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!content) {
                    throw new Error('Empty response from AI');
                }

                return content;
            }

            // Initialize app
            document.addEventListener('DOMContentLoaded', () => {
                loadSettings();

                // Auto-resize textarea
                htmlInput.addEventListener('input', () => {
                    htmlInput.style.height = 'auto';
                    htmlInput.style.height = htmlInput.scrollHeight + 'px';
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            if (!generateBtn.disabled) {
                                generateBtn.click();
                            }
                        } else if (e.key === ',' && e.shiftKey) {
                            e.preventDefault();
                            openModal();
                        }
                    }
                });

                showToast('E2E Locator Generator ready!', 'success');
            });
        </script>
</body>

</html>
